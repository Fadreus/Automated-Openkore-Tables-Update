#!/usr/bin/env perl
###############################################################################
# Automatically create a pull request containing official server changes,
# extracted from the server's patch files.
#
# WARNING: This script will DELETE all local modifications to the git clone
#          it uses. Please use a git directory which is only for this script
#          to avoid loss of any changes you might have made.

use strict;
use warnings;

use POSIX qw(strftime);

my $config;
my $datetime;
my $commit_message;
my $pullrq_message;

sub new {
	my ( $self, $server );
    my $class = shift;
	$datetime = strftime '%Y-%m-%d', gmtime()
	$commit_message = "[$datetime] update $server files";
	$pullrq_message = "- [ ] QA Review\n\nThis pull request was auto-generated by automated-update: https://github.com/alisonrag/automated-openkore-tables-update";
    return bless {}, $class;
}

sub setup_git_dir {
	my ( $self, $git_dir, $branch ) = @_;

	if ( !-d $git_dir ) {
		my $dirname = ( $git_dir =~ m{(.*)/} )[0];
		system "mkdir -p '$dirname'" if $dirname;
		system "git clone git\@github.com:OpenKore/openkore.git '$git_dir'";

		if ( !-d $git_dir ) {
			print "Updates directory is missing and cannot be created: $!\n";
			exit;
		}
	}

	chdir $git_dir;

	# Make sure we start out on master.
	system 'git checkout master';

	# Remove all untracked files.
	system 'git clean -d -f';

	# Fetch the latest code from github.
	system 'git fetch --all';

	# Remove remote-tracking references that have been removed upstream. (Eg, the branch was merged and deleted.)
	system 'git fetch --prune origin';

	# Revert all locally modified files.
	system 'git reset --hard origin/master';

	my $remote_branches = [ map { s{^\s+|origin/|\s+$}{}gs;$_; } split /\n/, `git branch -r` ];
	my $local_branches  = [ map { s/^[\s*]+|\s+$//gs;$_; } split /\n/,       `git branch` ];

	# If we have a local branch, always delete it. We'll re-generate it anyway,
	# and it's probably not in sync with the origin (if the origin has it too).
	if ( grep { $_ eq $branch } @$local_branches ) {
		system "git branch -D $branch";
	}

	my $remote_exists = grep { $_ eq $branch } @$remote_branches;
	if ( $remote_exists ) {
		system "git checkout $branch";
		system "git clean -d -f";
		system "git reset --hard origin/$branch";
	}
}

sub commit {
	my ( $self, $branch, $server ) = @_;

	my $out = `git ls-files -m`;
	if ( !$out || $out =~ /^\s+$/s ) {
		print "No changes!\n";
		return;
	}
	
	my $remote_branches = [ map { s{^\s+|origin/|\s+$}{}gs;$_; } split /\n/, `git branch -r` ];
	my $remote_exists = grep { $_ eq $branch } @$remote_branches;

	system "git checkout -b $branch" if !$remote_exists;
	system "git commit -a -m '$commit_message'";
	system "git push -u origin $branch";

	my $commit_header = "[$datetime] $server update";
	# This will fail if there's already an open pull for this branch. And that is good.
	system "hub pull-request -b master -h $branch -m '$commit_header\n\n$pullrq_message'";
}

1;